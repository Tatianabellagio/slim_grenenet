// Author: Tati
// simulate evolution of qtl under different environments defined by an optima file using tree seq from grenenet vcf file

initialize() {
	//setSeed(1455193095666); //commented for now so each replicate is different
	//constants
	
	//heritability 
	defineConstant('h2', 0.4);
	// tree file
	if (!exists("tree"))defineConstant('tree', 'test3august25.trees');

	// for the optima and variances i will import the files containign the values and the index coming from the bash script to refer to them
	if (!exists("optima_index"))defineConstant('optima_index', 0);  
	optima_values = readFile(optima_file);                                                                
	defineConstant('optima_value', asFloat(optima_values[asInteger(optima_index)]));    

	if (!exists("variance_index"))defineConstant('variance_index', 0);  
	variance_values = readFile(variance_file);                                                                
	defineConstant('variance_value', asFloat(variance_values[asInteger(variance_index)]));    
	
	initializeSLiMModelType("nonWF");
	initializeTreeSeq(retainCoalescentOnly=F);
	initializeMutationRate(0);
	initializeMutationType("m0", 0, "f", 0.0);
	m0.convertToSubstitution = F;
	initializeGenomicElementType("g1", m0, 1.0);
	// the genomic element will be of the size of the arabidopsis genome
	initializeGenomicElement(g1, 0, 119146347);
	// setting up the recombination rates in between chromosomes 
	rates = c(3e-6, 0.5, 3e-6, 0.5, 3e-6, 0.5, 3e-6, 0.5, 3e-6);
	ends = c(30427670, 30427671, 50125959, 50125960, 73585789, 73585790, 92170845, 92170846, 119146347);
	initializeRecombinationRate(rates, ends);
}

1 first() {
	// import tree of arabidopsis 5 chromosomes 
	sim.readFromPopulationFile(tree);

}

1 reproduction() {
	// this first reproduction callbacks has the purpose of increasing the population size 
	// for each of the individuals 
	for (ind in sim.subpopulations[0].individuals){
		// add 5 clones 
		for (i in 1:10){
			sim.subpopulations[0].addCloned(ind);
		}
	}
	self.active = 0;
}

// I will always keep the effect of the mutations neutral 
// becuase I am actually using their effect as an effect size 
1:999 mutationEffect(m0) {
	return 1.;
}

2 early(){
   // here i convert all individuals to 0 age, since this is actually my first tick, 
	// the previous one i just use to clone individuals 
	sim.subpopulations.individuals.age = rep(0, sim.subpopulations[0].individualCount);
}

2:999 early(){
	// before calculating fitness for this population, kill the 'parents' after the repduction stage
	inds = sim.subpopulations.individuals; 
	sim.killIndividuals(inds[inds.age > 0]);
	if (sim.subpopulations[0].individualCount > 1){
		// This callback is the one actually caclulating fitness in a vectorized way so it can be used in the fitnessEffect and reproduciton callback 
		inds =  sim.subpopulations.individuals;
		// calculate their additive genetic value 
		additive = inds.sumOfMutationsOfType(m0);
		VA = sd(additive)^2;
		// from h2 and VA calculate VE
		VE = (VA - h2 * VA) / h2;    // from h2 = VA / (VA + VE)   
		// save it for this tick 
		env_noise = rnorm(size(inds), 0.0, sqrt(VE));
		//calculate phenotype
		phenotype = additive + env_noise;
   
		//calculate fitness 
		fitness = exp(-0.5 * ((phenotype - asFloat(optima_value))^2)/variance_value);

		// set up the fitness of the population to be usen in the reproduction callback
        
		sim.subpopulations[0].setValue('fitness', fitness);
		//set up the fitness for each individual to be used in the fitnesseffect callback
		for (i in 0:(size(sim.subpopulations[0].individuals)-1)) {
			inds[i].setValue('fitness', fitness[i]);
		}
		// save values in files
		// save pop size 
    	writeFile(output_pop_size, asString(sim.subpopulations[0].individualCount), append = T);
		//save additive genetic variance
    	writeFile(output_va, asString(VA), append = T);
		// save phenotipic variance
    	writeFile(output_vpheno, asString(var(phenotype)), append = T);
		// save mean fitness and variance of fitness
    	writeFile(output_mfitness, asString(mean(fitness)), append = T);
    	writeFile(output_vfitness, asString(var(fitness)), append = T);
        
	}
}



2:999 fitnessEffect() {
	fitness = individual.getValue("fitness");
	return fitness;
}


3:999 reproduction() {
	// only run this if population size if greater than 0, would run into error otherwise 
	if (sim.subpopulations[0].individualCount > 0){
		
		fitness = sim.subpopulations[0].getValue("fitness");
		
		offspring = fitness * 100;  //max number of offsrping 
		offspring = asInteger(floor((offspring)));
		
		// loop over each of the individuals in the population
		for (j in 0:(size(sim.subpopulations[0].individuals)-1)) {
			// for each individual cehck their expected offspring size and based on that
			// for each offspring based on a chance of 97% make it a selfer offscpring or an outcross offspring 
			for (k in seqLen(offspring[j])) {
				
				if (runif(1) < 0.97)
				{
					sim.subpopulations[0].addSelfed(sim.subpopulations[0].individuals[j]);
				}
				else
				{
					//for the outcrossign event chose at random another individual from teh population 
					mate = sim.subpopulations[0].sampleIndividuals(1);
					sim.subpopulations[0].addCrossed(sim.subpopulations[0].individuals[j], mate);
				}
			}
		}
	}
	self.active = 0;
}

2:9 late(){

	if (sim.subpopulations[0].individualCount > 0){
		// if after the survival event the population size is too big adjust it 
		if (sim.subpopulations[0].individualCount > 900){
			number_to_kill = sim.subpopulations[0].individualCount - 900;
			sim.killIndividuals(sim.subpopulations[0].sampleIndividuals(number_to_kill));
		}
		// if all individuals died finish the simulation
		else {
            writeFile(output_file, '');
			sim.simulationFinished();
		}
	
	}
}


10 late() {
	if (sim.subpopulations[0].individualCount > 1){
		
		// if after the survival event the population size is too big adjust it 
		if (sim.subpopulations[0].individualCount > 900){
			number_to_kill = sim.subpopulations[0].individualCount - 900;
			sim.killIndividuals(sim.subpopulations[0].sampleIndividuals(number_to_kill));
		}
		//output tree seq 
		sim.treeSeqOutput(output_file);
		
		//output population size
		//writeFile('output_selection/var' + variance + '_optima' + optima_value + '_popsize.txt', asString(sim.subpopulations[0].individualCount));
		
		sim.simulationFinished();
	}
	// if there are no individuals create an empty file for the trees file
	else {
	writeFile(output_file, '');
	//writeFile('output_selection/var' + variance + '_optima' + optima_value + '_popsize.txt', asString(sim.subpopulations[0].individualCount));

	sim.simulationFinished(); 
	
	}


}
